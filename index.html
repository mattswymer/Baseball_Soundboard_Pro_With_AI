<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Baseball Soundboard Pro</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  /* Base styles for a dark theme */
  body {
    background-color: #1a202c; /* gray-900 */
    color: #f7fafc; /* gray-100 */
    font-family: 'Inter', sans-serif;
    padding: 1.5rem;
  }

  /* Custom styles for the toggle switch for a cleaner look */
  .toggle {
    position: relative;
    width: 42px;
    height: 24px;
  }
  .toggle input {
    display: none;
  }
  .toggle .track {
    position: absolute;
    inset: 0;
    border-radius: 9999px;
    background: #475569; /* slate-700 */
    transition: 0.2s;
  }
  .toggle .thumb {
    position: absolute;
    top: 2px;
    left: 2px;
    width: 20px;
    height: 20px;
    background: #fff;
    border-radius: 9999px;
    transition: 0.2s;
  }
  .toggle input:checked + .track {
    background: #22c55e; /* green-500 */
  }
  .toggle input:checked + .track .thumb {
    transform: translateX(18px);
  }

  /* Styling for play/pause/stop buttons */
  .btn-playpause {
    background-color: #22c55e; /* green-500 */
    color: white;
    border-radius: 9999px;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  }
  .btn-stop {
    background-color: #dc2626; /* red-600 */
    color: white;
    border-radius: 9999px;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  }
  .dragging { opacity: .5; }

  /* Progress bar styling */
  .progress-bar-wrap {
    height: 8px;
    background-color: #334155; /* slate-800 */
    border-radius: 9999px;
    overflow: hidden;
  }
  .progress-bar {
    height: 100%;
    width: 0%;
    background-color: #3b82f6; /* blue-500 */
  }
  .progress-bar-wrap:hover .progress-bar {
    cursor: pointer;
  }

  /* Drop zone styling */
  .drop-zone {
    transition: all 0.2s ease;
  }
  .drop-zone.drag-over {
    border-color: #0ea5e9 !important;
    background-color: rgba(14, 165, 233, 0.1) !important;
  }
  .modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.75);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }
  .modal-content {
    background-color: #1a202c;
    padding: 2rem;
    border-radius: 1rem;
    color: white;
    max-width: 90%;
    width: 400px;
  }
  .recording-pulse {
      background-color: #dc2626; /* red-600 */
      animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
  }
  @keyframes pulse {
    0%, 100% {
      opacity: 1;
    }
    50% {
      opacity: 0.5;
    }
  }
</style>
</head>
<body class="bg-gray-900 text-white p-6">
  <header class="flex flex-col md:flex-row items-center justify-between mb-6 gap-4">
    <h1 class="text-3xl font-bold flex items-center gap-3">
      <span>‚öæ</span> Baseball Soundboard Pro
    </h1>
      <div class="flex items-center gap-2 text-sm text-gray-400">
    Like this app? Buy me a coffee!
    <a href="https://www.paypal.me/mattswymer84" target="_blank" title="PayPal">
      <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/0e/PayPal_2024_%28Icon%29.svg/250px-PayPal_2024_%28Icon%29.svg.png" alt="PayPal" class="h-6 w-auto" />
    </a>
    <a href="https://venmo.com/mattswymer" target="_blank" title="Venmo">
      <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/84/Venmo_logo.png/1200px-Venmo_logo.png" alt="Venmo" class="h-6 w-auto" />
    </a>
  </div>
    <div class="flex flex-wrap items-center gap-6">
      <div class="flex items-center gap-3">
        <label for="fadeInSlider" class="text-sm shrink-0">Fade In (s)</label>
        <input id="fadeInSlider" type="range" min="0" max="8" step="0.1" value="2.0" class="w-24 md:w-40" />
        <span id="fadeInVal" class="w-8 text-right">2.0</span>
      </div>
      <div class="flex items-center gap-3">
        <label for="fadeOutSlider" class="text-sm shrink-0">Fade Out (s)</label>
        <input id="fadeOutSlider" type="range" min="0" max="8" step="0.1" value="2.0" class="w-24 md:w-40" />
        <span id="fadeOutVal" class="w-8 text-right">2.0</span>
      </div>
      <button id="fadeAll" class="bg-red-600 hover:bg-red-500 active:bg-red-700 px-4 py-2 rounded-xl font-semibold shadow">Fade Out All</button>
    </div>
  </header>

  <section class="mb-6">
    <div class="bg-slate-800/50 border border-slate-700 rounded-2xl p-4">
      <div class="grid grid-cols-1 lg:grid-cols-12 gap-4 items-center">
        <div class="lg:col-span-6">
          <label for="ttsText" class="sr-only">Text to generate speech from</label>
          <input
            id="ttsText"
            type="text"
            placeholder="Now batting, number 42, Jackie Robinson..."
            class="w-full bg-slate-900 border border-slate-600 rounded-xl px-4 py-2 text-white placeholder-slate-400 focus:border-blue-500 focus:outline-none"
          />
        </div>

        <div class="lg:col-span-5 flex flex-col sm:flex-row gap-2">
          <label for="voiceSelect" class="sr-only">Select voice</label>
          <select id="voiceSelect" class="bg-slate-900 border border-slate-600 rounded-xl px-3 py-2 text-white focus:border-blue-500 focus:outline-none text-sm min-w-0 flex-1">
            <option value="">Loading voices...</option>
          </select>
          <div class="flex gap-2 shrink-0">
            <button id="previewBtn" class="bg-blue-600 hover:bg-blue-500 active:bg-blue-700 px-3 py-2 rounded-xl text-sm font-semibold shadow transition-colors whitespace-nowrap">
              üîä Preview
            </button>
            <button id="generateBtn" class="bg-green-600 hover:bg-green-500 active:bg-green-700 px-3 py-2 rounded-xl text-sm font-semibold shadow transition-colors whitespace-nowrap">
              ‚ûï Add
            </button>
          </div>
        </div>

        <div class="lg:col-span-1 flex justify-center lg:justify-end">
          <div class="relative">
            <button
              id="recordBtn"
              class="w-14 h-14 bg-slate-700 hover:bg-slate-600 border-2 border-slate-600 rounded-full flex items-center justify-center text-xl transition-all duration-200 select-none"
              title="Hold to record"
            >
              üéôÔ∏è
            </button>
            <div id="recordingTooltip" class="absolute -top-12 left-1/2 transform -translate-x-1/2 bg-slate-900 text-white text-xs px-2 py-1 rounded-lg opacity-0 pointer-events-none transition-opacity duration-200 whitespace-nowrap z-10">
              Hold to record
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <main class="grid grid-cols-1 md:grid-cols-2 gap-6">
    <section>
      <div class="flex items-center gap-2 text-lg font-semibold mb-2">
        <span>üì¢ Announcements</span>
        <span id="annCount" class="text-xs bg-slate-700 px-2 py-0.5 rounded">0</span>
      </div>
      <div id="annCol"
           class="drop-zone group relative p-4 min-h-[260px] border-2 border-dashed border-slate-700 rounded-2xl bg-slate-800/30"
           aria-labelledby="annDropText">
        <label for="annInput" class="sr-only">Add announcement sounds</label>
        <div id="annDropText" class="drop-area pointer-events-none absolute inset-0 flex flex-col items-center justify-center text-slate-400 group-[.has-items]:hidden">
          <div class="text-3xl">Ôºã</div>
          <div>Drop sounds here or click to import</div>
        </div>
      </div>
      <input id="annInput" type="file" accept="audio/*" multiple class="hidden" />
    </section>

    <section>
      <div class="flex items-center gap-2 text-lg font-semibold mb-2">
        <span>üéµ Music</span>
        <span id="musicCount" class="text-xs bg-slate-700 px-2 py-0.5 rounded">0</span>
      </div>
      <div id="musicCol"
           class="drop-zone group relative p-4 min-h-[260px] border-2 border-dashed border-slate-700 rounded-2xl bg-slate-800/30"
           aria-labelledby="musicDropText">
        <label for="musicInput" class="sr-only">Add music sounds</label>
        <div id="musicDropText" class="drop-area pointer-events-none absolute inset-0 flex flex-col items-center justify-center text-slate-400 group-[.has-items]:hidden">
          <div class="text-3xl">Ôºã</div>
          <div>Drop sounds here or click to import</div>
        </div>
      </div>
      <input id="musicInput" type="file" accept="audio/*" multiple class="hidden" />
    </section>
  </main>

  <div id="modal" class="modal-overlay hidden">
    <div class="modal-content">
      <h3 class="text-xl font-bold mb-4">Message</h3>
      <p id="modal-message"></p>
      <div class="mt-4 text-right">
        <button id="modal-close" class="bg-blue-600 hover:bg-blue-500 active:bg-blue-700 px-4 py-2 rounded-xl font-semibold shadow">OK</button>
      </div>
    </div>
  </div>
<script>
// ===== Utility Functions =====
const $ = (sel, root = document) => root.querySelector(sel);
const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));
const formatTime = (sec) => {
  if (isNaN(sec) || !isFinite(sec)) return '0:00';
  const m = Math.floor(sec / 60);
  const s = Math.floor(sec % 60).toString().padStart(2, '0');
  return `${m}:${s}`;
};
const showMessage = (message) => {
  const modal = $('#modal');
  $('#modal-message').textContent = message;
  modal.classList.remove('hidden');
  $('#modal-close').onclick = () => {
    modal.classList.add('hidden');
  };
};

// ===== IndexedDB & LocalStorage Management =====
const DB_NAME = 'soundboardDB';
const DB_VERSION = 1;
const STORE_NAME = 'sounds';
const SETTINGS_KEY = 'sb_settings_v1';

async function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (e) => {
      e.target.result.createObjectStore(STORE_NAME);
    };
    req.onsuccess = (e) => resolve(e.target.result);
    req.onerror = (e) => reject(e);
  });
}
async function idbSet(key, value) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readwrite');
    tx.objectStore(STORE_NAME).put(value, key);
    tx.oncomplete = () => resolve();
    tx.onerror = (e) => reject(e);
  });
}
async function idbGet(key) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readonly');
    const req = tx.objectStore(STORE_NAME).get(key);
    req.onsuccess = () => resolve(req.result);
    req.onerror = (e) => reject(e);
  });
}
async function idbGetAllKeys() {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readonly');
    const req = tx.objectStore(STORE_NAME).getAllKeys();
    req.onsuccess = () => resolve(req.result);
    req.onerror = (e) => reject(e);
  });
}
async function idbDelete(key) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readwrite');
    tx.objectStore(STORE_NAME).delete(key);
    tx.oncomplete = () => resolve();
    tx.onerror = (e) => reject(e);
  });
}
function saveSettingsLS(data) {
  localStorage.setItem(SETTINGS_KEY, JSON.stringify(data));
}
function loadSettingsLS() {
  return JSON.parse(localStorage.getItem(SETTINGS_KEY) || '{}');
}

// ===== State Variables =====
let fadeInTime = 2.0;
let fadeOutTime = 2.0;
const columns = [{ wrap: $('#annCol'), input: $('#annInput') }, { wrap: $('#musicCol'), input: $('#musicInput') }];
const activeAudios = new Set();
let mediaRecorder;
let audioChunks = [];
let isRecording = false;
let microphoneStream = null;
let hasMicPermission = false;
let activeUtterances = new Set();

// ===== UI & Event Handling =====
function setHasItemsClass(col) {
  if (col.querySelectorAll('.sound-card').length > 0) {
    col.classList.add('has-items');
  } else {
    col.classList.remove('has-items');
  }
}
function updateCounts() {
  $('#annCount').textContent = $('#annCol').querySelectorAll('.sound-card').length;
  $('#musicCount').textContent = $('#musicCol').querySelectorAll('.sound-card').length;
  columns.forEach(c => setHasItemsClass(c.wrap));
}

function makeToggle(labelText) {
  const wrap = document.createElement('label');
  wrap.className = 'flex items-center gap-2 text-xs select-none';
  wrap.innerHTML = `
    <span>${labelText}</span>
    <span class="toggle inline-block">
      <input type="checkbox" />
      <span class="track"><span class="thumb"></span></span>
    </span>`;
  return { wrap, input: wrap.querySelector('input') };
}

// Refactored Card builder for both audio files and TTS announcements
function createCard({ name, url, blob, idbKey, text, voiceName }) {
  const card = document.createElement('div');
  card.idbKey = idbKey || null;
  card.className = 'sound-card group/card bg-slate-800 border border-slate-700 rounded-2xl p-3 mb-3 shadow flex flex-col gap-2 cursor-grab';
  card.draggable = true;
  card.dataset.type = text ? 'tts' : 'audio';

  const row = document.createElement('div');
  row.className = 'flex items-center gap-3';
  card.appendChild(row);

  const dragDot = document.createElement('div');
  dragDot.className = 'text-slate-500 cursor-grab select-none';
  dragDot.textContent = '‚ãÆ‚ãÆ';

  const playBtn = document.createElement('button');
  playBtn.className = 'btn-playpause shrink-0';
  playBtn.setAttribute('aria-label', 'Play');
  playBtn.innerHTML = '‚ñ∂';

  const stopBtn = document.createElement('button');
  stopBtn.className = 'btn-stop shrink-0';
  stopBtn.setAttribute('aria-label', 'Stop');
  stopBtn.innerHTML = '‚èπ';

  const title = document.createElement('div');
  title.className = 'font-semibold flex-1 truncate';
  title.textContent = name;

  const editBtn = document.createElement('button');
  editBtn.className = 'text-slate-300 hover:text-white';
  editBtn.setAttribute('title', 'Rename');
  editBtn.innerHTML = '‚úé';

  const delBtn = document.createElement('button');
  delBtn.className = 'text-slate-300 hover:text-red-400';
  delBtn.setAttribute('title', 'Delete');
  delBtn.innerHTML = 'üóë';

  row.append(dragDot, playBtn, stopBtn, title, editBtn, delBtn);

  let isPlaying = false;
  let audio, utterance;
  
  if (card.dataset.type === 'audio') {
    // Logic for local audio files
    const toggles = document.createElement('div');
    toggles.className = 'flex items-center gap-4 pl-14';
    const fadeInT = makeToggle('Fade In');
    const fadeOutT = makeToggle('Fade Out');
    fadeInT.input.checked = true;
    fadeOutT.input.checked = true;
    toggles.append(fadeInT.wrap, fadeOutT.wrap);
    card.appendChild(toggles);
    
    const progressWrap = document.createElement('div');
    progressWrap.className = 'pl-14';
    progressWrap.innerHTML = `
      <div class="progress-bar-wrap"><div class="progress-bar"></div></div>
      <div class="flex justify-between text-xs text-slate-300 mt-0.5">
        <span class="cur">0:00</span>
        <span class="dur">0:00</span>
      </div>`;
    const progressBg = progressWrap.querySelector('.progress-bar-wrap');
    const progress = progressWrap.querySelector('.progress-bar');
    const curLbl = progressWrap.querySelector('.cur');
    const durLbl = progressWrap.querySelector('.dur');
    card.appendChild(progressWrap);

    audio = new Audio();
    if (url) {
      audio.src = url;
    } else if (blob) {
      audio.src = URL.createObjectURL(blob);
    }
    audio.preload = 'metadata';
    audio.crossOrigin = 'anonymous';
    audio.volume = 1;
    card.audioElement = audio;

    const updateDuration = () => { durLbl.textContent = formatTime(audio.duration); };
    audio.addEventListener('loadedmetadata', updateDuration);
    if (audio.readyState >= 1) updateDuration();

    audio.addEventListener('timeupdate', () => {
      if (!isNaN(audio.duration) && audio.duration > 0) {
        progress.style.width = `${(audio.currentTime / audio.duration) * 100}%`;
        curLbl.textContent = formatTime(audio.currentTime);
      }
    });
    progressBg.addEventListener('click', (e) => {
      if (!isNaN(audio.duration) && audio.duration > 0) {
        const rect = progressBg.getBoundingClientRect();
        audio.currentTime = ((e.clientX - rect.left) / rect.width) * audio.duration;
      }
    });
    audio.addEventListener('ended', () => {
      isPlaying = false;
      setActive(false);
      progress.style.width = '0%';
      curLbl.textContent = '0:00';
      activeAudios.delete(audio);
    });

    playBtn.addEventListener('click', () => {
      if (!isPlaying) {
        if (fadeInT.input.checked) audio.volume = 0;
        audio.play();
        isPlaying = true;
        setActive(true);
        activeAudios.add(audio);
        if (fadeInT.input.checked) fadeTo(audio, 1, Math.round(fadeInTime * 1000));
        else audio.volume = 1;
      } else {
        if (fadeOutT.input.checked) {
          fadeTo(audio, 0, Math.round(fadeOutTime * 1000), {
            stopAfter: true, reset: false, onDone: () => { isPlaying = false; setActive(false); activeAudios.delete(audio); }
          });
        } else {
          audio.pause();
          isPlaying = false;
          setActive(false);
          activeAudios.delete(audio);
        }
      }
    });
    stopBtn.addEventListener('click', () => {
      if (fadeOutT.input.checked && !audio.paused && audio.volume > 0) {
        fadeTo(audio, 0, Math.round(fadeOutTime * 1000), {
          stopAfter: true, reset: true, onDone: () => { isPlaying = false; setActive(false); activeAudios.delete(audio); }
        });
      } else {
        audio.pause();
        audio.currentTime = 0;
        isPlaying = false;
        setActive(false);
        activeAudios.delete(audio);
      }
    });
  } else {
    // Logic for TTS cards
    card.dataset.text = text;
    card.dataset.voice = voiceName;
    
    playBtn.addEventListener('click', () => {
      if ('speechSynthesis' in window) {
        window.speechSynthesis.cancel();
        utterance = new SpeechSynthesisUtterance(text);
        utterance.voice = window.speechSynthesis.getVoices().find(v => v.name === voiceName);
        window.speechSynthesis.speak(utterance);
        isPlaying = true;
        setActive(true);
        activeUtterances.add(utterance);
        utterance.onend = () => {
          isPlaying = false;
          setActive(false);
          activeUtterances.delete(utterance);
        };
      } else {
        showMessage("Browser TTS is not supported.");
      }
    });

    stopBtn.addEventListener('click', () => {
      if ('speechSynthesis' in window) {
        window.speechSynthesis.cancel();
        isPlaying = false;
        setActive(false);
        activeUtterances.clear();
      }
    });
  }

  delBtn.addEventListener('click', () => {
    if (!confirm('Delete this sound?')) return;
    try {
      if (card.dataset.type === 'audio') {
        audio.pause();
        activeAudios.delete(audio);
      } else {
        if (window.speechSynthesis.speaking) window.speechSynthesis.cancel();
      }
    } catch {}
    card.remove();
    updateCounts();
    if (card.idbKey) idbDelete(card.idbKey);
    if (blob) URL.revokeObjectURL(audio.src);
  });

  function setActive(on) {
    if (on) {
      card.classList.add('ring-2', 'ring-blue-400', 'bg-slate-700');
      playBtn.innerHTML = '‚è∏';
      playBtn.setAttribute('aria-label', 'Pause');
    } else {
      card.classList.remove('ring-2', 'ring-blue-400', 'bg-slate-700');
      playBtn.innerHTML = '‚ñ∂';
      playBtn.setAttribute('aria-label', 'Play');
    }
  }

  function fadeTo(audio, target, durationMs, { stopAfter = false, reset = false, onDone } = {}) {
    const start = audio.volume;
    const startTime = performance.now();
    const dur = Math.max(0, durationMs);
    if (audio.__fadeRaf) cancelAnimationFrame(audio.__fadeRaf);
    function step(t) {
      const p = dur === 0 ? 1 : Math.min(1, (t - startTime) / dur);
      audio.volume = start + (target - start) * p;
      if (p < 1) {
        audio.__fadeRaf = requestAnimationFrame(step);
      } else {
        if (stopAfter) { audio.pause(); if (reset) audio.currentTime = 0; }
        if (onDone) onDone();
      }
    }
    audio.__fadeRaf = requestAnimationFrame(step);
  }

  editBtn.addEventListener('click', () => {
    const newName = prompt('Rename sound', title.textContent.trim());
    if (newName && newName.trim()) title.textContent = newName.trim();
  });

  card.addEventListener('dragstart', (e) => {
    card.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
  });
  card.addEventListener('dragend', () => card.classList.remove('dragging'));
  return card;
}

// Function to add files from a file system to a column
function addFilesToColumn(files, columnEl) {
  files.forEach(file => {
    if ([...columnEl.querySelectorAll('.sound-card')].some(c => c.idbKey === file.name)) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
      const arrayBuffer = e.target.result;
      const col = columnEl.id === 'annCol' ? 'ann' : 'music';
      await idbSet(file.name, { name: file.name, buffer: arrayBuffer, type: file.type, col });
      const blob = new Blob([arrayBuffer], { type: file.type });
      const card = createCard({
        name: file.name.replace(/\.[^/.]+$/, ''),
        blob,
        idbKey: file.name
      });
      columnEl.appendChild(card);
      updateCounts();
    };
    reader.readAsArrayBuffer(file);
  });
}

// Function to restore saved sounds from IndexedDB
async function restoreFromDB() {
  const keys = await idbGetAllKeys();
  for (const key of keys) {
    const rec = await idbGet(key);
    if (!rec || !rec.col) continue;

    if (rec.type === 'tts') {
      const targetCol = rec.col === 'ann' ? $('#annCol') : $('#musicCol');
      if ([...targetCol.querySelectorAll('.sound-card')].some(c => c.dataset.text === rec.name && c.dataset.voice === rec.voiceName)) continue;
      const card = createCard({ name: rec.name, text: rec.text, voiceName: rec.voiceName, idbKey: rec.idbKey || rec.name });
      targetCol.appendChild(card);
    } else {
      const blob = new Blob([rec.buffer], { type: rec.type });
      const targetCol = rec.col === 'ann' ? $('#annCol') : $('#musicCol');
      if ([...targetCol.querySelectorAll('.sound-card')].some(c => c.idbKey === rec.name)) continue;
      const card = createCard({ name: rec.name.replace(/\.[^/.]+$/, ''), blob, idbKey: rec.name });
      targetCol.appendChild(card);
    }
  }
  updateCounts();
}

// ===== Browser TTS Functionality =====
function generateBrowserTTS(text, voiceName, action) {
  if (!('speechSynthesis' in window)) {
    showMessage("Browser TTS is not supported in this browser.");
    return;
  }
  if (!text) {
    showMessage("Please enter some text to generate audio.");
    return;
  }
  
  if (action === 'preview') {
    window.speechSynthesis.cancel();
    const utterance = new SpeechSynthesisUtterance(text);
    const selectedVoice = window.speechSynthesis.getVoices().find(v => v.name === voiceName);
    if (selectedVoice) {
      utterance.voice = selectedVoice;
      window.speechSynthesis.speak(utterance);
    } else {
      showMessage(`The selected voice "${voiceName}" is not available.`);
    }
  } else if (action === 'add') {
    const name = text;
    const textKey = `tts_${name}_${voiceName}`;
    const card = createCard({ name, text, voiceName, idbKey: textKey });
    $('#annCol').appendChild(card);
    updateCounts();

    // Persist TTS cards to IndexedDB
    idbSet(textKey, { name: text, text, voiceName, type: 'tts', col: 'ann' });
  }
}

// ===== Recording Functionality =====
async function getMicrophoneStream() {
  if (microphoneStream) return microphoneStream;
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    microphoneStream = stream;
    hasMicPermission = true;
    return stream;
  } catch (err) {
    hasMicPermission = false;
    showMessage("Microphone access denied or unavailable. Please enable it in browser settings.");
    return null;
  }
}
function startRecording(stream) {
  if (isRecording || !stream) return;
  try {
    const mime = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 'audio/webm;codecs=opus' : '';
    mediaRecorder = mime ? new MediaRecorder(stream, { mimeType: mime }) : new MediaRecorder(stream);
  } catch (e) {
    console.error('MediaRecorder not supported:', e);
    showMessage('Recording not supported on this browser/device.');
    return;
  }
  audioChunks = [];
  mediaRecorder.ondataavailable = e => { if (e.data && e.data.size > 0) audioChunks.push(e.data); };
  mediaRecorder.onstop = async () => {
    const type = audioChunks[0]?.type || 'audio/webm';
    const audioBlob = new Blob(audioChunks, { type });
    const fileName = `Recording_${Date.now()}.${type.split('/')[1] || 'webm'}`;
    const arrayBuffer = await audioBlob.arrayBuffer();
    await idbSet(fileName, { name: fileName, buffer: arrayBuffer, type, col: 'ann' });
    const card = createCard({ name: 'Recording ' + new Date().toLocaleTimeString(), blob: audioBlob, idbKey: fileName });
    $('#annCol').appendChild(card);
    updateCounts();
  };
  mediaRecorder.start();
  isRecording = true;
  recordBtn.classList.add('recording-pulse');
  recordBtn.innerHTML = 'üî¥';
  $('#recordingTooltip').textContent = 'Release to save';
  $('#recordingTooltip').style.opacity = '1';
}
function stopRecording() {
  if (!isRecording) return;
  mediaRecorder.stop();
  isRecording = false;
  recordBtn.classList.remove('recording-pulse');
  recordBtn.innerHTML = 'üéôÔ∏è';
  $('#recordingTooltip').textContent = 'Hold to record';
  $('#recordingTooltip').style.opacity = '0';
}

const recordBtn = $('#recordBtn');
recordBtn.addEventListener('pointerdown', async (e) => {
  e.preventDefault();
  if (!hasMicPermission) { await getMicrophoneStream(); return; }
  startRecording(microphoneStream);
});
recordBtn.addEventListener('pointerup', () => { if (isRecording) stopRecording(); });
recordBtn.addEventListener('pointercancel', () => { if (isRecording) stopRecording(); });

// ===== Initialization and Event Listeners =====
const voiceSelect = $('#voiceSelect');
window.speechSynthesis.onvoiceschanged = () => {
  const voices = window.speechSynthesis.getVoices();
  voiceSelect.innerHTML = '<option value="">Select a voice...</option>';
  voices.forEach(voice => {
    const option = document.createElement('option');
    option.value = voice.name;
    option.textContent = `${voice.name} (${voice.lang})`;
    voiceSelect.appendChild(option);
  });
  // If voices are already loaded, populate immediately
  if (voices.length > 0) {
    const lastSelectedVoice = localStorage.getItem('lastSelectedVoice');
    if (lastSelectedVoice && voices.some(v => v.name === lastSelectedVoice)) {
        voiceSelect.value = lastSelectedVoice;
    } else {
        voiceSelect.value = voices[0].name;
    }
  }
};

voiceSelect.addEventListener('change', () => {
    localStorage.setItem('lastSelectedVoice', voiceSelect.value);
});

// Initial voice population call
if (window.speechSynthesis.getVoices().length > 0) {
  window.speechSynthesis.onvoiceschanged();
}


$('#previewBtn').addEventListener('click', () => {
  const text = $('#ttsText').value.trim();
  const voiceName = $('#voiceSelect').value;
  generateBrowserTTS(text, voiceName, 'preview');
});
$('#generateBtn').addEventListener('click', () => {
  const text = $('#ttsText').value.trim();
  const voiceName = $('#voiceSelect').value;
  generateBrowserTTS(text, voiceName, 'add');
});
$('#fadeInSlider').addEventListener('input', e => {
  fadeInTime = parseFloat(e.target.value);
  $('#fadeInVal').textContent = fadeInTime.toFixed(1);
  saveSettingsLS({ fadeIn: fadeInTime, fadeOut: fadeOutTime });
});
$('#fadeOutSlider').addEventListener('input', e => {
  fadeOutTime = parseFloat(e.target.value);
  $('#fadeOutVal').textContent = fadeOutTime.toFixed(1);
  saveSettingsLS({ fadeIn: fadeInTime, fadeOut: fadeOutTime });
});
$('#fadeAll').addEventListener('click', () => {
  window.speechSynthesis.cancel();
  $$('.sound-card').forEach(card => {
    if (card.dataset.type === 'audio') {
      const audio = card.audioElement;
      if (audio && !audio.paused) card.querySelector('.btn-stop').click();
    }
  });
});
columns.forEach(({ wrap, input }) => {
  wrap.addEventListener('click', (e) => {
    if (e.target === wrap || e.target.closest('.drop-area')) input.click();
  });
  wrap.addEventListener('dragenter', (e) => {
    e.preventDefault();
    const dragging = $('.dragging');
    if (!dragging) wrap.classList.add('drag-over');
  });
  wrap.addEventListener('dragover', (e) => {
    e.preventDefault();
    const dragging = $('.dragging');
    if (dragging) {
      wrap.classList.remove('drag-over');
      wrap.classList.add('ring-2', 'ring-sky-500');
      const afterElement = getDragAfterElement(wrap, e.clientY);
      if (afterElement == null) wrap.appendChild(dragging);
      else wrap.insertBefore(dragging, afterElement);
    } else {
      wrap.classList.add('drag-over');
    }
  });
  wrap.addEventListener('dragleave', (e) => {
    if (!wrap.contains(e.relatedTarget)) {
      wrap.classList.remove('ring-2', 'ring-sky-500', 'drag-over');
    }
  });
  wrap.addEventListener('drop', async (e) => {
    e.preventDefault();
    wrap.classList.remove('ring-2', 'ring-sky-500', 'drag-over');
    const files = Array.from(e.dataTransfer.files || []).filter(f => f.type.startsWith('audio/'));
    if (files.length) {
      addFilesToColumn(files, wrap);
    } else {
      const dragging = $('.dragging');
      if (dragging && dragging.parentElement !== wrap) {
        wrap.appendChild(dragging);
        updateCounts();
        if (dragging.idbKey) {
            const newCol = wrap.id === 'annCol' ? 'ann' : 'music';
            const rec = await idbGet(dragging.idbKey);
            if (rec) {
                rec.col = newCol;
                await idbSet(dragging.idbKey, rec);
            }
        }
      }
    }
    updateCounts();
  });
  input.addEventListener('change', (e) => {
    const files = Array.from(e.target.files || []);
    if (files.length) { addFilesToColumn(files, wrap); input.value = ''; }
  });
});
function getDragAfterElement(container, y) {
  const draggableElements = [...container.querySelectorAll('.sound-card:not(.dragging)')];
  return draggableElements.reduce((closest, child) => {
    const box = child.getBoundingClientRect();
    const offset = y - box.top - box.height / 2;
    if (offset < 0 && offset > closest.offset) return { offset: offset, element: child };
    else return closest;
  }, { offset: Number.NEGATIVE_INFINITY }).element;
}

window.addEventListener('DOMContentLoaded', async () => {
  const s = loadSettingsLS();
  fadeInTime = s.fadeIn ? parseFloat(s.fadeIn) : 2.0;
  fadeOutTime = s.fadeOut ? parseFloat(s.fadeOut) : 2.0;
  $('#fadeInSlider').value = fadeInTime;
  $('#fadeOutSlider').value = fadeOutTime;
  $('#fadeInVal').textContent = fadeInTime.toFixed(1);
  $('#fadeOutVal').textContent = fadeOutTime.toFixed(1);
  await restoreFromDB();
});

if ('serviceWorker' in navigator) navigator.serviceWorker.register('./service-worker.js');
</script>
</body>
</html>
